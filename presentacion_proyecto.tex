\documentclass[aspectratio=169]{beamer}

% Tema
\usetheme{Madrid}
\usecolortheme{default}

% Paquetes
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{tikz}
\usepackage{amsmath}
\usepackage{graphicx}

% Configuración de código
\lstset{
    language=C++,
    basicstyle=\ttfamily\footnotesize,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{gray}\itshape,
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=5pt,
    backgroundcolor=\color{white},
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    frame=single,
    tabsize=2,
    breaklines=true,
    breakatwhitespace=false
}

% Información
\title{Sistema de Control Autónomo Distribuido con ESP8266}
\subtitle{Aplicación de Lenguajes de Alto Nivel en Sistemas Embebidos}
\author{Pablo Navarro}
\institute{Lenguajes de Alto Nivel para Aplicaciones Industriales}
\date{Diciembre 2025}

\begin{document}

% Portada
\frame{\titlepage}

% Índice
\begin{frame}{Contenido}
    \tableofcontents
\end{frame}

% ====================
% INTRODUCCIÓN
% ====================
\section{Introducción}

\begin{frame}{Contexto del Proyecto}
    \begin{columns}
        \column{0.5\textwidth}
        \textbf{Objetivo:}
        \begin{itemize}
            \item Sistema de control distribuido
            \item Vehículos robot autónomos
            \item Comunicación inalámbrica
            \item Tiempo real ($<$30ms)
        \end{itemize}
        
        \vspace{0.5cm}
        \textbf{Lenguaje:}
        \begin{itemize}
            \item C++ con framework Arduino
            \item Programación orientada a objetos
            \item Abstracciones de alto nivel
        \end{itemize}
        
        \column{0.5\textwidth}
        \begin{center}
            \begin{tikzpicture}[scale=0.8]
                % Maestro
                \draw[thick, fill=blue!30] (0,0) rectangle (2,1.5);
                \node at (1,0.75) {\small\textbf{Maestro}};
                
                % Esclavo
                \draw[thick, fill=green!30] (4,0) rectangle (6,1.5);
                \node at (5,0.75) {\small\textbf{Esclavo}};
                
                % Comunicación
                \draw[->, thick, red, line width=1.5pt] (2,1) -- (4,1);
                \node at (3,1.3) {\tiny ESP-NOW};
                
                % Sensores
                \draw[<-, thick] (1,-0.5) -- (1,0);
                \node at (1,-0.7) {\tiny Sensores};
                
                % Motores
                \draw[->, thick] (5,-0.5) -- (5,0);
                \node at (5,-0.7) {\tiny Motores};
            \end{tikzpicture}
        \end{center}
    \end{columns}
\end{frame}

\begin{frame}{¿Por qué Lenguajes de Alto Nivel?}
    \begin{block}{Ventajas Tradicionales}
        \begin{itemize}
            \item Mayor productividad del desarrollador
            \item Código más mantenible y legible
            \item Menos errores de programación
            \item Portabilidad entre plataformas
        \end{itemize}
    \end{block}
    
    \vspace{0.3cm}
    
    \begin{alertblock}{Desafío}
        ¿Pueden los lenguajes de alto nivel cumplir requisitos de \textbf{tiempo real} en sistemas embebidos industriales?
    \end{alertblock}
    
    \vspace{0.3cm}
    
    \begin{exampleblock}{Hipótesis}
        C++ con Arduino puede lograr latencias $<$30ms en control de vehículos autónomos
    \end{exampleblock}
\end{frame}

% ====================
% ARQUITECTURA
% ====================
\section{Arquitectura del Sistema}

\begin{frame}{Plataforma Hardware}
    \begin{columns}
        \column{0.6\textwidth}
        \textbf{ESP8266 LOLIN D1:}
        \begin{itemize}
            \item CPU: 32-bit @ 80/160 MHz
            \item RAM: 80 KB usuario
            \item Flash: 4 MB
            \item WiFi: 802.11 b/g/n
            \item GPIO: 17 pines
        \end{itemize}
        
        \vspace{0.3cm}
        
        \textbf{Sensores/Actuadores:}
        \begin{itemize}
            \item HC-SR04: Sensor ultrasónico
            \item LM393: Sensor de luz
            \item L9110S: Driver de motores
            \item LEDs de iluminación
        \end{itemize}
        
        \column{0.4\textwidth}
        \begin{center}
            \textbf{Conexiones}
            \vspace{0.2cm}
            
            {\footnotesize
            \begin{tabular}{|l|l|}
                \hline
                \textbf{Pin} & \textbf{Función} \\
                \hline
                D1, D2 & Motor Izq \\
                D3, D4 & Motor Der \\
                D5 & TRIG \\
                D6 & ECHO \\
                D7 & LM393 \\
                D8 & LEDs \\
                \hline
            \end{tabular}
            }
        \end{center}
    \end{columns}
\end{frame}

\begin{frame}{Arquitectura Distribuida}
    \begin{center}
        \begin{tikzpicture}[scale=1.2]
            % Maestro
            \draw[thick, fill=blue!20] (0,0) rectangle (3.5,2.5);
            \node at (1.75,2.1) {\textbf{MAESTRO}};
            \node[align=left] at (1.75,1.2) {
                \footnotesize
                • Lee sensores\\
                • Toma decisiones\\
                • Envía comandos\\
                • Servidor web
            };
            
            % Esclavo
            \draw[thick, fill=green!20] (7,0) rectangle (10.5,2.5);
            \node at (8.75,2.1) {\textbf{ESCLAVO}};
            \node[align=left] at (8.75,1.2) {
                \footnotesize
                • Recibe comandos\\
                • Verifica seguridad\\
                • Ejecuta control\\
                • Servidor web
            };
            
            % Comunicación
            \draw[->, ultra thick, red] (3.5,1.5) -- (7,1.5) 
                node[midway, above] {\small ESP-NOW 50Hz};
            \draw[->, ultra thick, blue] (7,1) -- (3.5,1) 
                node[midway, below] {\small ACK};
            
            % Sensores maestro
            \draw[<-, thick] (0.7,-0.5) -- (0.7,0) node[below] at (0.7,-0.5) {\tiny Dist};
            \draw[<-, thick] (1.75,-0.5) -- (1.75,0) node[below] at (1.75,-0.5) {\tiny Luz};
            
            % Sensores esclavo
            \draw[<-, thick] (7.7,-0.5) -- (7.7,0) node[below] at (7.7,-0.5) {\tiny Dist};
            
            % Actuadores esclavo
            \draw[->, thick] (9.8,-0.5) -- (9.8,0) node[below] at (9.8,-0.5) {\tiny Motores};
        \end{tikzpicture}
    \end{center}
    
    \vspace{0.3cm}
    
    \begin{block}{Flujo de Control}
        Medición $\rightarrow$ Decisión $\rightarrow$ Transmisión $\rightarrow$ Validación $\rightarrow$ Actuación
    \end{block}
\end{frame}

\begin{frame}[fragile]{Diseño Orientado a Objetos}
    \begin{columns}
        \column{0.55\textwidth}
        \begin{lstlisting}[basicstyle=\ttfamily\tiny]
class Coche {
private:
    // Hardware
    int motorIzqA, motorIzqB;
    int motorDerA, motorDerB;
    int trigPin, echoPin;
    int lightPin, lucesPin;
    
    // Estado
    float distMin, distMax;
    int luzActual;
    unsigned long ultimoCambio;
    
public:
    // Inicializacion
    void configurar(...);
    void inicializarESPNow();
    void inicializarWebServer();
    
    // Control
    void moverMotores(int vel);
    void controlarDistancia();
    void controlarLuces();
    
    // Sensores
    float leerDistancia();
    int leerLuzAmbiente();
    
    // Comunicacion
    void enviarComando(...);
    void ejecutarComando(...);
};
        \end{lstlisting}
        
        \column{0.45\textwidth}
        \textbf{Ventajas OOP:}
        \begin{itemize}
            \item \textbf{Encapsulación:} Estado protegido
            \item \textbf{Reutilización:} Misma clase para ambos
            \item \textbf{Abstracción:} Interfaz simple
            \item \textbf{Mantenibilidad:} Cambios localizados
        \end{itemize}
        
        \vspace{0.3cm}
        
        \begin{exampleblock}{Código Compartido}
            Maestro y esclavo usan la misma clase \texttt{Coche}, solo difieren en configuración de pines
        \end{exampleblock}
    \end{columns}
\end{frame}

% ====================
% IMPLEMENTACIÓN
% ====================
\section{Implementación}

\begin{frame}[fragile]{Comunicación ESP-NOW Optimizada}
    \begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
void Coche::enviarComandoESPNow(int luz, float dist) {
    static unsigned long ultimoEnvio = 0;
    unsigned long ahora = millis();
    
    // Throttling: 50 Hz (20ms minimo)
    if (ahora - ultimoEnvio < 20) {
        return;  // Evitar saturacion
    }
    
    // Formatear mensaje: "luz=1,dist=25.5"
    String mensaje = "luz=" + String(luz) + 
                     ",dist=" + String(dist, 1);
    
    // Enviar via ESP-NOW
    esp_now_send(macEsclavo, 
                 (uint8_t*)mensaje.c_str(), 
                 mensaje.length());
    
    ultimoEnvio = ahora;
}
    \end{lstlisting}
    
    \begin{block}{Características}
        \textbf{Frecuencia:} 50 Hz • \textbf{Latencia:} 10-20ms • \textbf{Alcance:} 30-50m
    \end{block}
\end{frame}

\begin{frame}[fragile]{Algoritmo de Control de Distancia}
    \begin{columns}
        \column{0.6\textwidth}
        \begin{lstlisting}[basicstyle=\ttfamily\tiny]
void Coche::controlarDistancia() {
    float d = leerDistancia();
    
    // Zona muerta: 15-20 cm
    if (d > distMin && d < distMax) {
        detenerMotores();
        return;
    }
    
    int vel = 0;
    
    // Retroceso: d < 15 cm
    if (d <= distMin) {
        vel = 80 + (distMin - d) * 10;
        vel = constrain(vel, 80, 180);
    }
    // Avance: d > 20 cm
    else {
        vel = -(100 + (d - distMax) * 7.75);
        vel = constrain(vel, -255, -100);
    }
    
    moverMotores(vel);
}
        \end{lstlisting}
        
        \column{0.4\textwidth}
        \textbf{Control Proporcional:}
        
        \begin{align*}
            v_{ret} &= 80 + (15-d) \times 10 \\
            v_{av} &= -(100 + (d-20) \times 7.75)
        \end{align*}
        
        \vspace{0.3cm}
        
        \begin{tikzpicture}[scale=0.6]
            \draw[->] (0,0) -- (5,0) node[right] {$d$ (cm)};
            \draw[->] (0,-2) -- (0,2) node[above] {$v$ (PWM)};
            
            % Zona muerta
            \fill[green!20] (1.5,-0.1) rectangle (2,0.1);
            \node at (1.75,-0.5) {\tiny zona};
            \node at (1.75,-0.7) {\tiny muerta};
            
            % Retroceso
            \draw[blue, thick] (0,1.5) -- (1.5,0);
            \node at (0.5,1.2) {\tiny retro};
            
            % Avance
            \draw[red, thick] (2,0) -- (4.5,-1.8);
            \node at (3.5,-1.2) {\tiny avance};
        \end{tikzpicture}
    \end{columns}
\end{frame}

\begin{frame}[fragile]{Sistema de Seguridad}
    \begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
void Coche::ejecutarComandoRecibido(String comando) {
    // SEGURIDAD: Verificar obstaculos antes de ejecutar
    if (trigPin != -1 && echoPin != -1) {
        float distSeguridad = leerDistancia();
        if (distSeguridad < 5.0 && distSeguridad > 0) {
            detenerMotores();  // PARADA DE EMERGENCIA
            return;  // Ignorar comando
        }
    }
    
    // Parsear comando: "luz=1,dist=25.5"
    int luzRecibida = parsearLuz(comando);
    float distRecibida = parsearDistancia(comando);
    
    // Ejecutar control
    controlarLucesAutomaticas(luzRecibida);
    controlarDistancia();  // Usa distancia local del esclavo
}
    \end{lstlisting}
    
    \begin{alertblock}{Parada de Emergencia}
        Esclavo verifica obstáculos $<$5cm \textbf{antes} de ejecutar cualquier comando
    \end{alertblock}
\end{frame}

\begin{frame}[fragile]{Control de Luces con Histéresis}
    \begin{columns}
        \column{0.55\textwidth}
        \begin{lstlisting}[basicstyle=\ttfamily\tiny]
void Coche::controlarLucesAutomaticas(
    int luz) {
    if (lucesPin == -1) return;
    
    unsigned long ahora = millis();
    
    // Histéresis: 5 segundos minimo
    if (ahora - ultimoCambioLuces < 5000) {
        return;  // Mantener estado
    }
    
    // Permitir cambio
    if (luz != luzActual) {
        luzActual = luz;
        ultimoCambioLuces = ahora;
        
        // Logica invertida
        digitalWrite(lucesPin, 
                     luz == 1 ? HIGH : LOW);
    }
}
        \end{lstlisting}
        
        \column{0.45\textwidth}
        \textbf{Anti-Parpadeo:}
        
        \begin{tikzpicture}[scale=0.7]
            \draw[->] (0,0) -- (6,0) node[right] {$t$ (s)};
            \draw[->] (0,0) -- (0,3) node[above] {Luz};
            
            % Señal ruidosa
            \draw[gray, dashed] plot[domain=0:5.5, samples=50] 
                (\x, {1.5 + 0.8*sin(10*\x r)});
            \node at (5.5,2.5) {\tiny ruidosa};
            
            % Señal filtrada
            \draw[blue, ultra thick] (0,0.8) -- (2,0.8) -- 
                (2,2.2) -- (5.5,2.2);
            \node at (5.5,1.5) {\tiny filtrada};
            
            % Histéresis
            \draw[<->, red] (2,0.3) -- (4,0.3) 
                node[midway, below] {\tiny 5s};
        \end{tikzpicture}
        
        \vspace{0.2cm}
        
        \begin{block}{Histéresis Temporal}
            Cambios de luz requieren 5 segundos de estabilidad
        \end{block}
    \end{columns}
\end{frame}

% ====================
% RESULTADOS
% ====================
\section{Resultados}

\begin{frame}{Métricas de Rendimiento}
    \begin{columns}
        \column{0.5\textwidth}
        \begin{table}
            \centering
            {\small
            \begin{tabular}{|l|c|}
                \hline
                \textbf{Métrica} & \textbf{Valor} \\
                \hline
                Latencia promedio & 28.5 ms \\
                Latencia mínima & 22 ms \\
                Latencia máxima & 35 ms \\
                \hline
                Desv. estándar & 3.2 ms \\
                Mensajes perdidos & 0.4\% \\
                \hline
                Error seguimiento & $\pm$2 cm \\
                Parada emergencia & $<$5 ms \\
                \hline
            \end{tabular}
            }
        \end{table}
        
        \column{0.5\textwidth}
        \textbf{Desglose de Latencia:}
        
        \begin{tikzpicture}[scale=0.8]
            \draw[fill=blue!30] (0,0) rectangle (1,0.8) node[pos=.5] {\tiny 2-5ms};
            \node at (0.5,-0.3) {\tiny Sensor};
            
            \draw[fill=green!30] (1.5,0) rectangle (2.5,0.8) node[pos=.5] {\tiny 1-2ms};
            \node at (2,-0.3) {\tiny Proc};
            
            \draw[fill=red!30] (3,0) rectangle (5,0.8) node[pos=.5] {\tiny 10-20ms};
            \node at (4,-0.3) {\tiny ESP-NOW};
            
            \draw[fill=green!30] (5.5,0) rectangle (6.5,0.8) node[pos=.5] {\tiny 1-2ms};
            \node at (6,-0.3) {\tiny Proc};
            
            \draw[fill=orange!30] (7,0) rectangle (8.5,0.8) node[pos=.5] {\tiny 5-10ms};
            \node at (7.75,-0.3) {\tiny Motor};
            
            \draw[<->] (0,1.2) -- (8.5,1.2) node[midway, above] {\small 22-35 ms total};
        \end{tikzpicture}
    \end{columns}
    
    \vspace{0.3cm}
    
    \begin{exampleblock}{Validación}
        Sistema cumple requisito de latencia $<$30ms en promedio
    \end{exampleblock}
\end{frame}

\begin{frame}{Análisis de Memoria}
    \begin{columns}
        \column{0.5\textwidth}
        \textbf{Uso de Flash:}
        
        \begin{tikzpicture}[scale=0.8]
            \draw[fill=blue!40] (0,0) rectangle (4,0.7) node[pos=.5] {256 KB};
            \node at (2,-0.3) {\small Framework Arduino};
            
            \draw[fill=green!40] (0,1) rectangle (0.5,1.7) node[pos=.5, rotate=90] {\tiny 8};
            \node at (0.25,2) {\tiny Clase};
            
            \draw[fill=red!40] (0.7,1) rectangle (1.3,1.7) node[pos=.5, rotate=90] {\tiny 12};
            \node at (1,2) {\tiny ESP-NOW};
            
            \draw[fill=orange!40] (1.5,1) rectangle (3,1.7) node[pos=.5] {\tiny 32};
            \node at (2.25,2) {\tiny Web};
            
            \draw[<->] (0,-0.8) -- (4,-0.8) node[midway, below] {\textbf{310 KB Flash}};
        \end{tikzpicture}
        
        \column{0.5\textwidth}
        \textbf{Uso de RAM:}
        
        \begin{tikzpicture}[scale=0.8]
            \draw[fill=blue!40] (0,0) rectangle (3,0.7) node[pos=.5] {20 KB};
            \node at (1.5,-0.3) {\small Framework};
            
            \draw[fill=green!40] (0,1) rectangle (0.6,1.7) node[pos=.5, rotate=90] {\tiny 4};
            \node at (0.3,2) {\tiny Coche};
            
            \draw[fill=red!40] (0.8,1) rectangle (1.6,1.7) node[pos=.5, rotate=90] {\tiny 6};
            \node at (1.2,2) {\tiny ESP};
            
            \draw[fill=orange!40] (1.8,1) rectangle (3,1.7) node[pos=.5] {\tiny 8};
            \node at (2.4,2) {\tiny Web};
            
            \draw[<->] (0,-0.8) -- (3,-0.8) node[midway, below] {\textbf{42 KB RAM}};
        \end{tikzpicture}
    \end{columns}
    
    \vspace{0.5cm}
    
    \begin{block}{Overhead Aceptable}
        Framework consume 30\% Flash y 25\% RAM, pero quedan 58\% de recursos disponibles
    \end{block}
\end{frame}

\begin{frame}{C++ vs C: Comparación}
    \begin{table}
        \centering
        \begin{tabular}{|l|c|c|c|}
            \hline
            \textbf{Aspecto} & \textbf{C++/Arduino} & \textbf{C Puro} & \textbf{Diferencia} \\
            \hline
            Líneas de código & 450 & $\sim$800 & \textcolor{green}{-44\%} \\
            Tiempo desarrollo & 2 semanas & 4-5 semanas & \textcolor{green}{-60\%} \\
            Bugs encontrados & 8 & $\sim$20 & \textcolor{green}{-60\%} \\
            \hline
            Uso Flash & 310 KB & 180 KB & \textcolor{red}{+72\%} \\
            Uso RAM & 42 KB & 32 KB & \textcolor{red}{+31\%} \\
            Latencia & 28.5 ms & 25 ms & \textcolor{red}{+14\%} \\
            \hline
            Portabilidad & Alta & Media & \textcolor{green}{+++} \\
            Mantenibilidad & Alta & Media & \textcolor{green}{+++} \\
            \hline
        \end{tabular}
    \end{table}
    
    \vspace{0.3cm}
    
    \begin{alertblock}{Balance Productividad vs Recursos}
        Mayor consumo de recursos compensado por desarrollo 2x más rápido y menos errores
    \end{alertblock}
\end{frame}

% ====================
% CONCLUSIONES
% ====================
\section{Conclusiones}

\begin{frame}{Ventajas de Lenguajes de Alto Nivel}
    \begin{columns}
        \column{0.5\textwidth}
        \begin{block}{Productividad}
            \begin{itemize}
                \item Desarrollo 2x más rápido
                \item 60\% menos bugs
                \item Código 44\% más compacto
                \item Curva de aprendizaje suave
            \end{itemize}
        \end{block}
        
        \begin{block}{Mantenibilidad}
            \begin{itemize}
                \item OOP: código organizado
                \item Encapsulación: cambios locales
                \item Reutilización: misma clase
                \item Documentación implícita
            \end{itemize}
        \end{block}
        
        \column{0.5\textwidth}
        \begin{block}{Abstracción}
            \begin{itemize}
                \item APIs intuitivas
                \item Gestión automática de memoria
                \item Bibliotecas multiplataforma
                \item Menos errores de punteros
            \end{itemize}
        \end{block}
        
        \begin{exampleblock}{Portabilidad}
            Código funciona en ESP8266, ESP32, Arduino sin cambios mayores
        \end{exampleblock}
    \end{columns}
\end{frame}

\begin{frame}{Limitaciones Encontradas}
    \begin{columns}
        \column{0.5\textwidth}
        \begin{alertblock}{Overhead de Recursos}
            \begin{itemize}
                \item Framework: 250 KB Flash base
                \item String: más RAM que char[]
                \item Vtables: 4-8 bytes por objeto
                \item 30\% más memoria vs C
            \end{itemize}
        \end{alertblock}
        
        \begin{alertblock}{Rendimiento}
            \begin{itemize}
                \item Abstracciones: 5-10\% overhead
                \item digitalWrite() más lento
                \item Virtualización: indirección
                \item 14\% más latencia vs C
            \end{itemize}
        \end{alertblock}
        
        \column{0.5\textwidth}
        \begin{alertblock}{Control Limitado}
            \begin{itemize}
                \item Acceso a bajo nivel complejo
                \item Interrupciones menos flexibles
                \item Optimizaciones ocultas
                \item Determinismo no garantizado
            \end{itemize}
        \end{alertblock}
        
        \vspace{0.3cm}
        
        \begin{block}{Mitigación}
            Combinar C++ para lógica y C para secciones críticas
        \end{block}
    \end{columns}
\end{frame}

\begin{frame}{Aplicabilidad Industrial}
    \begin{columns}
        \column{0.5\textwidth}
        \textbf{✓ Aplicaciones Adecuadas:}
        \begin{itemize}
            \item[$\checkmark$] Monitorización ($<$100ms)
            \item[$\checkmark$] Robótica de servicio
            \item[$\checkmark$] IoT industrial
            \item[$\checkmark$] Sistemas distribuidos
            \item[$\checkmark$] Prototipos rápidos
            \item[$\checkmark$] HMI y dashboards
        \end{itemize}
        
        \column{0.5\textwidth}
        \textbf{✗ Aplicaciones NO recomendadas:}
        \begin{itemize}
            \item[$\times$] Control hard real-time ($<$1ms)
            \item[$\times$] Safety-critical certificable
            \item[$\times$] Recursos $<$256KB Flash
            \item[$\times$] Determinismo absoluto
            \item[$\times$] Automotriz ASIL-D
            \item[$\times$] Aviación DO-178C
        \end{itemize}
    \end{columns}
    
    \vspace{0.5cm}
    
    \begin{exampleblock}{Regla General}
        Usar C++ para soft real-time ($>$10ms), C/ensamblador para hard real-time ($<$1ms)
    \end{exampleblock}
\end{frame}

\begin{frame}{Conclusiones Finales}
    \begin{enumerate}
        \item \textbf{Viabilidad Demostrada:} C++ con Arduino es viable para control en tiempo real no crítico (latencias 22-35ms)
        
        \vspace{0.3cm}
        
        \item \textbf{Balance Favorable:} Overhead de 30\% en recursos compensado por productividad 2x mayor
        
        \vspace{0.3cm}
        
        \item \textbf{OOP Efectiva:} Arquitectura orientada a objetos facilita mantenimiento y escalabilidad
        
        \vspace{0.3cm}
        
        \item \textbf{Apropiado para Industria 4.0:} Ideal para sistemas IoT, monitorización y robótica colaborativa
        
        \vspace{0.3cm}
        
        \item \textbf{Limitaciones Claras:} No reemplaza C/ensamblador en aplicaciones safety-critical o hard real-time
    \end{enumerate}
\end{frame}

\begin{frame}{Trabajo Futuro}
    \begin{columns}
        \column{0.5\textwidth}
        \textbf{Extensiones Técnicas:}
        \begin{itemize}
            \item Migrar a ESP32 (dual-core)
            \item Algoritmos avanzados (PID, Kalman)
            \item Comunicación mesh (N vehículos)
            \item Machine Learning (TensorFlow Lite)
        \end{itemize}
        
        \vspace{0.3cm}
        
        \textbf{Validación:}
        \begin{itemize}
            \item Certificación IEC 61508 (SIL 1-2)
            \item Testing formal (unit, integration)
            \item Análisis WCET (Worst-Case)
        \end{itemize}
        
        \column{0.5\textwidth}
        \textbf{Optimizaciones:}
        \begin{itemize}
            \item Híbrido C++/C para secciones críticas
            \item RTOS (FreeRTOS) para scheduling
            \item DMA para I/O sin polling
            \item Análisis estático (MISRA C++)
        \end{itemize}
        
        \vspace{0.3cm}
        
        \textbf{Investigación:}
        \begin{itemize}
            \item Benchmark detallado vs Rust
            \item Patrones de diseño embebidos
            \item Métricas de mantenibilidad
        \end{itemize}
    \end{columns}
\end{frame}

% Diapositiva final
\begin{frame}[plain]
    \begin{center}
        \vfill
        {\Huge Gracias por su atención}
        
        \vspace{1cm}
        
        {\Large Sistema de Control Autónomo ESP8266}
        
        \vspace{0.5cm}
        
        {\large Aplicación de Lenguajes de Alto Nivel en Sistemas Embebidos}
        
        \vspace{1cm}
        
        \textbf{Pablo Navarro}
        
        Diciembre 2025
        
        \vspace{0.5cm}
        
        \texttt{github.com/pnavarro3/CocheSE}
        
        \vfill
    \end{center}
\end{frame}

\end{document}
